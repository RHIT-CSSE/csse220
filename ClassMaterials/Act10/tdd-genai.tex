\model{TDD with genAI}

One of the challenges with TDD is the time overhead incurred by 
writing test cases one at a time, then context switching to 
implementation and refactoring. 
Since genAI tools have shown promise with code generation tasks 
and tend to hallucinate less often when provided with a ground truth to work from, 
some have suggested that genAI could speed up TDD. 
For example, 
\href{https://arxiv.org/abs/2405.10849}{this workshop paper} experiments with 
collaborative and fully-automated TDD using genAI tools. 
In this activity, 
we'll try out genAI-assisted TDD and discuss what to watch out for 
when using genAI tools in this way. 

\quest{20 min}

\Q Add a method stub for \java{subtract} in \emph{BadFrac.java}, 
giving it an appropriate signature and JavaDoc comment. 
Add the same line as in~\ref{tdd.tex}: 

\java{throw new UnsupportedOperationException("Not yet implemented");}
\begin{answer}[2em]
Expected signature: \java{public BadFrac subtract(BadFrac incoming)}
\end{answer}

\Q Based on the stated requirements of the \java{BadFrac} class, 
especially its constructor, what requirement(s) should we state 
for the \java{subtract} method? 
\begin{answer}[3em]
The \java{BadFrac} class represents nonnegative fractions, 
so we should require that \java{incoming} is less than or equal to \java{this}. 
\end{answer}

\Q Brainstorm test cases as a team, and 
add a JUnit test in \emph{BadFracTest.java} with your test cases. 
Run your JUnit test to make sure it fails in the expected way. 

\Q \emph{Split into pairs} (or stay as a group of three). 
\begin{itemize}
\item In one pair (or on one machine), implement the new feature manually. 
\item In the other pair (or on another machine), 
    provide a genAI tool of your choice with 
    \emph{BadFrac.java} and \emph{BadFracTest.java}, 
    then prompt it to implement the \java{subtract} method. 
\end{itemize}
\begin{answer}[3em]
TODO: add link to example genAI conversation
\end{answer}

\Q (\textbf{Regroup.}) 
Compare the manual and genAI implementations. 
Do both pass your JUnit tests? 
Which implementation seems better, and why? 
\begin{answer}
Answers will vary. 
\end{answer}

\Q If time allows, 
repeat the TDD process for a \java{divide} method, 
swapping manual/genAI pairs. 

\Q\label{genAITestCases} 
We might try further integrating genAI into TDD 
by having the genAI tool write test cases, too. 
Do you think this is a good idea? Discuss. 
\begin{answer}[5em]
One perspective: Having genAI write test cases might be dangerous, 
because it might not interpret the system requirements correctly. 
And then if you run the genAI-generated code 
and see it passes the genAI-generated tests, 
you might not review the tests and code as thoroughly as you should. 
\end{answer}

\Q Skim the ``Conclusions'' section of the \href{https://arxiv.org/abs/2405.10849}{workshop paper} 
mentioned at the top of~\ref{tdd-genai.tex}. 
What warnings do the authors include about using genAI with TDD? 
\begin{answer}[3em]
The genAI tool might change tests to match buggy code, 
rather than the other way around. 
The developer should carefully supervise the quality of the code produced. 
\end{answer}